(()=>{var t={30:(t,e,n)=>{"use strict";const{Univariate:r}=n(987),{timedPromise:s,getTime:i}=n(935),o=n(155),a="object"==typeof o&&"function"==typeof o.cpuUsage?()=>o.cpuUsage():()=>({});class c{constructor(){this._setup=t=>t,this._teardown=()=>{},this._solution={},this._asyncSolution={},this._onteardownfail=()=>{},this._progress=()=>{}}setup(t){return this._setup=t,this}teardown(t){return this._teardown=t,this}onTeardownFail(t){return this._onteardownfail=t,this}probe(t,e){const n=t.arg;if(!(Number.isInteger(n)&&n>0))throw new Error("probe requires positive integer {arg} parameter");return s("Setup",t.timeout,(t=>{const e=this._setup(n);e instanceof Promise?e.then(t):t(e)})).then((n=>s("Solution",t.timeout,(r=>{if(t.async){const t=i(),s=a();e(n,(e=>{const o=i(),c=a();r({arg:n,retVal:e,date1:t,date2:o,cpu1:s,cpu2:c})}))}else{const t=i(),s=a(),o=e(n),c=i(),u=a();console.log(),r({arg:n,retVal:o,date1:t,date2:c,cpu1:s,cpu2:u})}})))).then((e=>s("Teardown",t.timeout,(t=>{const r={n,input:e.arg,output:e.retVal},s=this._teardown(r);s instanceof Promise?s.then((n=>t({err:n,...e}))):t({err:s,...e})})))).then((e=>new Promise((r=>{const{cpu1:s,cpu2:i,date1:o,date2:a,err:c}=e,u=(a-o)/1e3,h={n,time:u,iter:u/n};c&&(h.err=c,this._onteardownfail({n,err:c,name:t.name})),void 0!==i.user&&(h.user=(i.user-s.user)/10**6,h.system=(i.system-s.system)/10**6,h.cpu=h.user+h.system),r(h)}))))}add(t,e){if("function"==typeof e)this._solution[t]=e,this._asyncSolution[t]=!1;else{if(e)throw new Error("A solution must be a function (or null to erase one)");delete this._solution[e]}return this}addAsync(t,e){if("function"==typeof e)this._solution[t]=e,this._asyncSolution[t]=!0;else{if(e)throw new Error("A solution must be a function (or null to erase one)");delete this._solution[e]}return this}list(){return Object.keys(this._solution).sort()}check(t=1,e=1){const n=Object.keys(this._solution).values(),r={},s=i=>{const o=n.next().value,a=this._asyncSolution[o];if(void 0===o)return i(0===Object.keys(r).length?void 0:r);this.probe({arg:e,name:o,timeout:t,async:a},this._solution[o]).then((t=>s(i))).catch((t=>{r[o]=t,s(i)}))};return new Promise(s)}progress(t){return this._progress=t,this}compare(t={}){const e=t.minArg??1,n=t.maxArg??1/0,r=t.maxTime,s=t.repeat??1,i={...this._solution};if(n===1/0&&!r&&!t.argList)throw new Error("One of maxArg, maxTime, of argList must be specified");const o=t.argList??function*(){for(let t=e;t<=n;t=Math.ceil(4*t/3))yield t}(),a=new Set(Object.keys(i)),c=function*(){for(const t of o){if(0===a.size)return;for(const e in i)if(a.has(e))for(let n=0;n<s;n++)yield{name:e,n:t}}}(),u={},h={};for(const t in i)u[t]=[],h[t]=0;let l=0,m=0;const f=(r??0)*Object.keys(i).length,p=t=>{const e=c.next().value;if(!e)return t(u);const{name:n,n:s}=e,o=this._asyncSolution[n];return this.probe({arg:s,name:n,async:o},i[n]).then((e=>{const i=h[n]+=e.time;i>r&&a.delete(n),u[n].push(e),this._progress({name:n,n:s,result:e,count:++l,cumulativeTime:i,maxTime:r,totalTime:m+=e.time,totalMaxTime:f}),setTimeout((()=>p(t)),0)}))};return new Promise(p)}static flattenData(t,e={}){const n=e.minTime||.004,r=e.useStat||"time",s={};for(let e in t){const i=u(t[e],r);s[e]=h(i,(t=>t.count()<14?t.median():t.clone({ltrim:7,rtrim:7,winsorize:!0}).mean()),(t=>t>=n))}const i=function(t){const e=new Set;for(const n of t)for(const t of n)e.add(t[0]);return[...e].sort(((t,e)=>t-e))}(Object.values(s)),o={n:i,times:{},ops:{}};for(let e in t){o.times[e]=[],o.ops[e]=[];for(let t of i){const n=s[e].get(t);o.times[e].push(n),o.ops[e].push(t/n)}}return o}static getTimeRes(t=15){const e=i();let n=e,r=t;for(;r>0;){const t=i();t!==n&&(n=t,r--)}return(n-e)/(1e3*t)}}function u(t,e="time"){const n=new Map;for(const s of t)n.has(s.n)||n.set(s.n,new r({precision:1e-12})),n.get(s.n).add(s[e]);return n}function h(t,e,n=(t=>!0)){return new Map([...t].map((t=>[t[0],e(t[1])])).filter((t=>n(t[1]))))}c.prototype.flattenData=c.flattenData,c.prototype.getTimeRes=c.getTimeRes,t.exports={ParaBench:c}},935:t=>{"use strict";const e="object"==typeof process&&"function"==typeof process.hrtime?()=>{const[t,e]=process.hrtime();return 1e3*t+e/1e6}:"object"==typeof performance&&"function"==typeof performance.now?()=>performance.now():()=>new Date-0;t.exports={timedPromise:function(t,e,n){let r;return new Promise(((s,i)=>{e>0&&(r=setTimeout((()=>{i(t+" timed out after "+e+" ms")}),e)),n(r?t=>{clearTimeout(),s(t)}:s)}))},getTime:e}},155:t=>{var e,n,r=t.exports={};function s(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(t){if(e===setTimeout)return setTimeout(t,0);if((e===s||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(n){try{return e.call(null,t,0)}catch(n){return e.call(this,t,0)}}}!function(){try{e="function"==typeof setTimeout?setTimeout:s}catch(t){e=s}try{n="function"==typeof clearTimeout?clearTimeout:i}catch(t){n=i}}();var a,c=[],u=!1,h=-1;function l(){u&&a&&(u=!1,a.length?c=a.concat(c):h=-1,c.length&&m())}function m(){if(!u){var t=o(l);u=!0;for(var e=c.length;e;){for(a=c,c=[];++h<e;)a&&a[h].run();h=-1,e=c.length}a=null,u=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===i||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{return n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function f(t,e){this.fun=t,this.array=e}function p(){}r.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];c.push(new f(t,e)),1!==c.length||u||o(m)},f.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=p,r.addListener=p,r.once=p,r.off=p,r.removeListener=p,r.removeAllListeners=p,r.emit=p,r.prependListener=p,r.prependOnceListener=p,r.listeners=function(t){return[]},r.binding=function(t){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(t){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},987:(t,e,n)=>{(()=>{const{Binning:e}=n(283),{Univariate:r}=n(207),s={Binning:e,Univariate:r};"undefined"!=typeof window&&(window.logstat=s),t.exports=s})()},283:t=>{"use strict";function e(t,n,r=10){if(t===n)return t;if(t*n<=0)return 0;if(n<0)return-e(-n,-t,r);if(t>n)return e(n,t,r);let s=-Math.floor(Math.log(n-t)/Math.log(r));for(;Math.ceil(t*r**s)<=Math.floor(n*r**s);)s--;return s++,s>=0?Math.ceil(t*r**s)/r**s:Math.ceil(t/r**-s)*r**-s}t.exports={Binning:class{constructor(t={}){let e=t.base||1.001,n=t.precision||1e-9;if(!(e>1&&e<1.5))throw new Error("base must be a number between 1 and 1.5");if(e+=1e-9,e=2**(1/Math.ceil(Math.log(2)/Math.log(e))),1===e)throw new Error("base too close to 1");n=Number.parseFloat(""+n);const r=n*Math.ceil(1/(e-1));this._thresh=r,this._precision=n,this._base=e}getBase(){return this._base}getPrecision(){return this._precision}round(t){if("number"!=typeof t&&(t=Number.parseFloat(t)),Number.isNaN(t))throw new Error("Attempt to round a non-numeric value: "+t);return t<0?-this.round(-t):t<this._thresh?Math.round(t/this._precision)*this._precision:this._thresh*this._base**Math.round(Math.log(t/this._thresh)/Math.log(this._base))}upper(t){return t<0?-this.lower(-t):(t=this.round(t))<this._thresh?t+this._precision/2:t*Math.sqrt(this._base)}lower(t){return t<0?-this.upper(-t):(t=this.round(t))<=this._thresh?t-this._precision/2:t/Math.sqrt(this._base)}shorten(t,n){return void 0===t?t:void 0===n?e(this.lower(t),this.upper(t)):e(t,n)}},shorten:e}},207:(t,e,n)=>{"use strict";const{Binning:r}=n(283);class s extends r{constructor(t={}){super(t),this.storage=new Map,this._count=0,this._cache={},this.neat=new i(this),t.bins&&this.addWeighted(t.bins)}add(...t){return this._cache={},t.forEach((t=>{const e=this.round(t),n=this.storage.get(e)??0;this.storage.set(e,n+1),this._count++})),this}addWeighted(t){return this._cache={},t.forEach((t=>{const e=t[0],n=Number.parseFloat(t[1]);if(Number.isNaN(n))throw new Error("Attempt to provide a non-numeric weight");const r=this.round(e),s=(this.storage.get(r)??0)+n;s<=0?(this.storage.delete(r),this._count+=n-s):(this.storage.set(r,s),this._count+=n)})),this}toJSON(){return{version:"stats-logscale/univariate@1.0",precision:this.getPrecision(),base:this.getBase(),bins:this.getBins()}}clone(t={}){let e=this.getBins(t);return t.transform&&(e=e.map((e=>[t.transform(e[0]),e[1]]))),new s({precision:t.precision??this.getPrecision(),base:t.base??this.getBase(),bins:e})}getBins(t){if(this._cache.data||(this._cache.data=[...this.storage].sort(((t,e)=>t[0]-e[0]))),!t)return this._cache.data;const e=Math.max(t.min??-1/0,this.percentile(t.ltrim??0)),n=Math.min(t.max??1/0,this.percentile(100-(t.rtrim??0)));if(!t.winsorize)return this._cache.data.filter((t=>t[0]>=e&&t[0]<=n));const r=[this.round(e),0],s=[this.round(n),0],i=[r];for(const[t,e]of this._cache.data)t<=r[0]?r[1]+=e:t>=s[0]?s[1]+=e:i.push([t,e]);return s[1]>0&&i.push(s),i}count(){return this._count}min(){const t=this.getBins();return this.lower(t[0][0])}max(){const t=this.getBins();return this.upper(t[t.length-1][0])}sumOf(t){let e=0;return[...this.storage].forEach((n=>{e+=n[1]*t(n[0])})),e}E(t){return this._count?this.sumOf(t)/this._count:void 0}mean(){return this._count?this.sumOf((t=>t))/this._count:void 0}stdev(){if(this._count<2)return;const t=this.mean();return Math.sqrt(this.sumOf((e=>(e-t)*(e-t)))/(this._count-1))}skewness(){const t=this.count();if(!(t<3))return t*t/((t-1)*(t-2))*this.momentStd(3)}kurtosis(){const t=this.count();if(t<4)return;const e=t*t*(t+1)/((t-1)*(t-2)*(t-3)),n=(t-1)*(t-1)/((t-2)*(t-3));return this.momentStd(4)*e-3*n}moment(t,e){if(!Number.isInteger(t))throw new Error("Cannot calculate non-integer moment (did you mean momentAbs?)");return void 0===e&&(e=this.mean()),this.E((n=>(n-e)**t))}momentAbs(t=1,e){return void 0===e&&(e=this.mean()),this.E((n=>Math.abs(n-e)**t))}momentStd(t){return this.moment(t)/this.stdev()**t}quantile(t){const e=t*this._count,n=this._cumulative();let r=0,s=n.length;for(;r+1<s;){const t=Math.floor((s+r)/2);n[t][1]>=e?s=t:r=t}const i=this.lower(n[r][0]);return i+(this.upper(n[r][0])-i)*(e-n[r][1])/(n[r][2]-n[r][1])}percentile(t){return this.quantile(t/100)}median(){return this.quantile(.5)}cdf(t){return this._rawCdf(t)/this._count}_rawCdf(t){const e=this._cumulative(),n=this.round(t);let r=0,s=e.length;for(;r<s;){const t=Math.floor((s+r)/2);e[t][0]<n?r=t+1:s=t}return r>=e.length?this._count:(r>0?e[r-1][2]:0)+(n!==e[r][0]?0:(e[r][2]-e[r][1])*(t-this.lower(t))/(this.upper(t)-this.lower(t)))}histogram(t={}){if(!this._count)return[];const e=this.min(),n=this.max(),r=t.count||10,s=[];let i=e;const o=(n-e)/r;for(let t=0;t<r;t++)s.push([this._rawCdf(i+o),i,i+=o]);for(let t=s.length;t-- >1;)s[t][0]-=s[t-1][0];if(s[0][0]-=this._rawCdf(e),t.scale){let e=0;for(let t=0;t<s.length;t++)e<s[t][0]&&(e=s[t][0]);for(let n=0;n<s.length;n++)s[n][0]=s[n][0]*t.scale/e}return s}_cumulative(){if(!this._cache.cumulative){const t=this.getBins(),e=[];let n=0;for(let r=0;r<t.length;r++)e.push([t[r][0],n,n+=t[r][1]]);this._cache.cumulative=e}return this._cache.cumulative}}["cdf+","kurtosis","max","mean","min","moment+","momentAbs+","momentStd+","quantile+","skewness","stdev"].forEach((t=>{const e=!!t.match(/\+/);e&&(t=t.replace("+",""));const n=s.prototype[t];if("function"!=typeof n)throw new Error('method "'+t+'" is cached but never defined');s.prototype[t]=e?function(...e){if(0===this._count)return;void 0===this._cache[t]&&(this._cache[t]={});const r=e.join(":");return void 0===this._cache[t][r]&&(this._cache[t][r]=n.apply(this,e)),this._cache[t][r]}:function(){if(0!==this._count)return void 0===this._cache[t]&&(this._cache[t]=n.apply(this)),this._cache[t]}}));class i{constructor(t){this._main=t}min(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[0][0])}max(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[t.length-1][0])}}["E","kurtosis","mean","median","moment","momentAbs","momentStd","percentile","quantile","skewness","stdev","sumOf"].forEach((t=>{i.prototype[t]=function(e){return this._main.shorten(this._main[t](e))}})),["cdf","count"].forEach((t=>{i.prototype[t]=function(e){return this._main[t](e)}})),t.exports={Univariate:s}}},e={};function n(r){var s=e[r];if(void 0!==s)return s.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,n),i.exports}(()=>{const{ParaBench:t}=n(30);window.ParaBench=t})()})();